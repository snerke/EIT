{"version":3,"sources":["components/Map/Map.js","App.js","serviceWorker.js","index.js"],"names":["Map","useState","map","setMap","mapLayers","setMapLayers","currentDate","setCurrentDate","mapContainer","useRef","useEffect","mapboxgl","accessToken","process","container","current","style","center","zoom","halifax","belfast_lough","avonmouth","milford_haven","st_john_nb","swansea","sydney_cb","liverpool","clyde","totalRouteNames","totalroute","dates","i","length","console","log","route","point","loadImage","error","image","addImage","addSource","lines","features","geometry","coordinates","line","push","routes","lineDistance","turf","arc","steps","segment","counter","addLayers","getStyle","sources","addNewLayer","gloshaugen","trondheim_vann","trondheim_veg","trondheim_bygg","mapSourceLength","Object","keys","mapLayersInOrder","layers","slice","obj","id","updateButtons","layerName","data","setTimeout","layerType","prompt","type","addLayer","randomizeColor","err","alert","removeAllLayers","layerSources","layerSource","removeLayer","removeSource","removeSingleLayer","selectedLayer","this","createBuffer","toggleSpinner","document","getElementById","value","bufferSize","turfed","getSource","_data","buffer","createUnion","selectedLayer1","selectedLayer2","replace","currUnion","createIntersect","layerType1","layerType2","unioned","currDiff","intersected","createDifference","createPoint","longCoord","parseFloat","latCoord","isNaN","showOrHide","visibility","getLayoutProperty","undefined","setLayoutProperty","textContent","randomColor","Math","floor","random","on","point_b","route_animate","paint","route_counter","animate","start","end","properties","bearing","setData","requestAnimationFrame","flyTo","addEventListener","speed","essential","changeDate","event","target","setPaintProperty","dragging","getLI","nodeName","toLowerCase","parentNode","spinner","display","buttons","getElementsByTagName","onclick","dataTransfer","preventDefault","bounding","getBoundingClientRect","offset","y","height","clientY","insertBefore","nextSibling","previousSibling","moveLayer","initializeMap","className","ref","el","class","styles","overflow","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.a44e248c.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport mapboxgl from \"mapbox-gl\";\r\nimport \"mapbox-gl/dist/mapbox-gl.css\";\r\nimport SidePanel from \"../SidePanel/SidePanel\";\r\nimport \"./Map.css\";\r\nimport gloshaugen from \"../../sample_data/gloshaugen.json\";\r\nimport trondheim_vann from \"../../sample_data/trondheim_vann4.json\";\r\nimport trondheim_bygg from \"../../sample_data/trondheim_bygg31.json\";\r\nimport trondheim_veg from \"../../sample_data/trondheim_veg7.json\";\r\nimport * as turf from '@turf/turf';\r\nimport buffer from \"@turf/buffer\";\r\n\r\nconst Map = () => {\r\n  const [map, setMap] = useState(null);\r\n  const [mapLayers, setMapLayers] = useState([]);\r\n  const [currentDate, setCurrentDate] = useState(\"-\")\r\n  const mapContainer = useRef(null);\r\n  //let currentDate = useRef(null)\r\n\r\n  useEffect(() => {\r\n    mapboxgl.accessToken = process.env.REACT_APP_MAPBOX_KEY;\r\n    const initializeMap = ({ setMap, mapContainer }) => {\r\n      const map = new mapboxgl.Map({\r\n        container: mapContainer.current,\r\n        style: \"mapbox://styles/mapbox/satellite-v9\", // stylesheet location\r\n        center: [-25, 45],\r\n        zoom: 3,\r\n      });\r\n\r\n    let halifax = [-63.582687, 44.651070];\r\n    let belfast_lough = [-5.785, 54.691];\r\n    let avonmouth = [-2.6987, 51.5034];\r\n    let milford_haven = [-5.0341, 51.7128];\r\n    let st_john_nb = [-66.0628, 45.2796];\r\n    let swansea = [-3.943646, 51.621441];\r\n    let sydney_cb = [-60.195556, 46.136389];\r\n    let liverpool = [-2.983333, 53.400002];\r\n    let father_point = [-68.461111, 48.513889];\r\n    let clyde = [-4.629179, 55.458565];\r\n\r\n\r\n    let totalRouteNames = [[\"Halifax\", halifax], [\"Belfast Lough\", belfast_lough], [\"Avonmouth\", avonmouth], [\"Milford Haven\", milford_haven]]\r\n    let totalroute = [st_john_nb, halifax, belfast_lough, avonmouth, milford_haven, st_john_nb, halifax, belfast_lough, swansea, milford_haven,\r\n    halifax, belfast_lough, avonmouth, milford_haven, halifax];\r\n    \r\n    let dates = [\"-\", \"Jan. 7, 1942 - Jan. 9, 1942\", \"Jan. 13, 1942 - Jan. 28, 1942\", \"Jan. 29, 1942 - Jan. 30, 1942\", \"Feb. 11, 1942 - Feb. 12, 1942\", \"Feb. 13, 1942 - Mar. 2, 1942\", \"Mar. 12, 1942 - Mar. 13, 1942\", \"Mar. 15, 1942 - Mar. 26, 1942\", \"Mar. 28, 1942 - Mar. 29, 1942\", \"Apr. 8, 1942 - Apr. 8, 1942\", \"Apr. 9, 1942 - Apr. 22, 1942\", \"Mai 10, 1942 - Mai 21, 1942\", \"Mai 23, 1942 - Mai 25, 1942\", \"14\", \"15\"];\r\n    //setCurrentDate(dates[0]);\r\n\r\n    for (let i = 0; i < totalRouteNames.length; i++) {\r\n      console.log(\"ÆÆÆ\", totalRouteNames[i])\r\n    }\r\n    \r\n    // A simple line from origin to destination.\r\n    let route = {\r\n    'type': 'FeatureCollection',\r\n    'features': [\r\n    {\r\n    'type': 'Feature',\r\n    'geometry': {\r\n    'type': 'LineString',\r\n    'coordinates': totalroute\r\n    }\r\n    }\r\n    ]\r\n    };\r\n\r\n    \r\n    // A single point that animates along the route.\r\n    // Coordinates are initially set to origin.\r\n    let point = {\r\n    'type': 'FeatureCollection',\r\n    'features': [\r\n    {\r\n    'type': 'Feature',\r\n    'properties': {},\r\n    'geometry': {\r\n    'type': 'Point',\r\n    'coordinates': halifax\r\n    }\r\n    }\r\n    ]\r\n    };\r\n\r\n\r\n    map.loadImage(\r\n      'https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png',\r\n      function (error, image) {\r\n      if (error) throw error;\r\n      map.addImage('custom-marker', image);\r\n      // Add a GeoJSON source with 2 points\r\n      map.addSource('points', {\r\n      'type': 'geojson',\r\n      'data': {\r\n      'type': 'FeatureCollection',\r\n      'features': [\r\n      /*\r\n      let halifax = [-63.582687, 44.651070];\r\n      let belfast_lough = [-5.785, 54.691];\r\n      let avonmouth = [-2.6987, 51.5034];\r\n      let milford_haven = [-5.0341, 51.7128];\r\n      let st_john_nb = [-66.0628, 45.2796];\r\n      let swansea = [-3.943646, 51.621441];\r\n      let sydney_cb = [-60.195556, 46.136389];\r\n      let liverpool = [-2.983333, 53.400002];\r\n      let father_point = [-68.461111, 48.513889];\r\n      let clyde = [-4.629179, 55.458565];\r\n      */\r\n      {\r\n        'type': 'Feature',\r\n        'geometry': {\r\n        'type': 'Point',\r\n        'coordinates': clyde\r\n        },\r\n        'properties': {\r\n        'title': 'Clyde,\\nSkottland'\r\n        }\r\n        },\r\n     {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': liverpool\r\n      },\r\n      'properties': {\r\n      'title': 'Liverpool,\\nEngland',\r\n      }\r\n      },\r\n      {\r\n        'type': 'Feature',\r\n        'geometry': {\r\n        'type': 'Point',\r\n        'coordinates': sydney_cb\r\n        },\r\n        'properties': {\r\n        'title': 'Sydney, C.B.,\\nCanada'\r\n        }\r\n        },\r\n     {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': swansea\r\n      },\r\n      'properties': {\r\n      'title': 'Swansea,\\nWales'\r\n      }\r\n      },\r\n     {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': st_john_nb\r\n      },\r\n      'properties': {\r\n      'title': 'St. John, N.B.,\\nCanada'\r\n      }\r\n      },\r\n     {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': milford_haven\r\n      },\r\n      'properties': {\r\n      'title': 'Milford Haven,\\nWales'\r\n      }\r\n      },\r\n      {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': avonmouth\r\n      },\r\n      'properties': {\r\n      'title': 'Avonmouth,\\nEngland'\r\n      }\r\n      },\r\n      {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': halifax\r\n      },\r\n      'properties': {\r\n      'title': 'Halifax,\\nCanada'\r\n      }\r\n      },\r\n      {\r\n      'type': 'Feature',\r\n      'geometry': {\r\n      'type': 'Point',\r\n      'coordinates': belfast_lough\r\n      },\r\n      'properties': {\r\n      'title': 'Belfast Lough,\\nNorthern Ireland'\r\n      }\r\n      }\r\n      ]\r\n      }\r\n      });\r\n       \r\n      // Add a symbol layer\r\n      /*map.addLayer({\r\n        'id': 'points',\r\n        'type': 'symbol',\r\n        'source': 'points',\r\n        'layout': {\r\n          'icon-image': 'custom-marker',\r\n          // get the title name from the source's \"title\" property\r\n          'text-field': ['get', 'title'],\r\n          'text-font': [\r\n            'Open Sans Semibold',\r\n            'Arial Unicode MS Bold'\r\n          ],\r\n          'text-offset': [0, 1.25],\r\n          'text-anchor': 'top'\r\n        },\r\n        paint: {\r\n          \"text-color\": \"white\"\r\n        }\r\n      });*/\r\n      }\r\n      );\r\n\r\n\r\n\r\n\r\n    let currentRoute = 0;\r\n\r\n    let lines = []\r\n    console.log(\"b\", route.features[0].geometry.coordinates)\r\n    for(let i = 0; i<route.features[0].geometry.coordinates.length-1; i++) {\r\n      let line = {\r\n        \"type\": \"Feature\",\r\n        \"properties\": {},\r\n        \"geometry\": {\r\n          \"type\": \"Line\",\r\n          \"coordinates\": [route.features[0].geometry.coordinates[i], route.features[0].geometry.coordinates[i+1]]\r\n        }\r\n      }\r\n      //console.log(line)\r\n      lines.push(line);\r\n      //console.log(\"lines\", lines)\r\n    }\r\n\r\n    //console.log(\"HER\", lines[0])\r\n\r\n    let routes = {\r\n      \"type\": \"FeatureCollection\",\r\n      \"features\": lines\r\n    }\r\n    console.log(\"routes\", routes);\r\n    \r\n    // Calculate the distance in kilometers between route start/end point.\r\n    let lineDistance = turf.length(route.features[0]);\r\n    console.log(\"lineDistance\", lineDistance)\r\n\r\n    /*let steps2 = 500;\r\n    let arc2;\r\n\r\n    for (let i = 0; i < routes.features.length - 1; i++) {\r\n      let pointA;\r\n      let pointB;\r\n\r\n      let currLine = {\r\n        'type': 'FeatureCollection',\r\n        'features': [\r\n          {\r\n            'type': 'Feature',\r\n            'geometry': {\r\n              'type': 'LineString',\r\n              'coordinates': [pointA, pointB]\r\n            }\r\n          }\r\n        ]\r\n      };\r\n      route.features[0].geometry.coordinates = arc2;\r\n\r\n      \r\n    }*/\r\n\r\n    //blir ikke brukt..\r\n    function animateLine(currentRoute) {\r\n      console.log(\"animateLine\");\r\n      \r\n      let pointA = routes.features[currentRoute];\r\n      let pointB = routes.features[currentRoute + 1];\r\n\r\n      let arc = []\r\n      \r\n      for (let i = 0; i < lineDistance; i += lineDistance / steps) {\r\n        let segment = turf.along(route.features[0], i);\r\n        arc.push(segment.geometry.coordinates);\r\n      }\r\n\r\n      currentRoute += 1;\r\n      if (currentRoute > routes.features) {\r\n        currentRoute = 0;\r\n      }\r\n    }\r\n\r\n\r\n    let arc = [];\r\n    // Number of steps to use in the arc and animation, more steps means\r\n    // a smoother arc and animation, but too many steps will result in a\r\n    // low frame rate\r\n    let steps = 500 * (totalroute.length - 1);\r\n    \r\n    // Draw an arc between the `origin` & `destination` of the two points\r\n    for (let i = 0; i < lineDistance; i += lineDistance / steps) {\r\n      let segment = turf.along(route.features[0], i);\r\n      arc.push(segment.geometry.coordinates);\r\n    }\r\n\r\n\r\n\r\n    \r\n    // Update the route with calculated arc coordinates\r\n    route.features[0].geometry.coordinates = arc;\r\n    \r\n    // Used to increment the value of the point measurement against the route.\r\n    let counter = 0;\r\n    \r\n    map.on('load', function () {\r\n    // Add a source and layer displaying a point which will be animated in a circle.\r\n    map.addSource('route', {\r\n    'type': 'geojson',\r\n    'data': route\r\n    });\r\n    \r\n    map.addSource('point', {\r\n    'type': 'geojson',\r\n    'data': point\r\n    });\r\n    \r\n    map.addLayer({\r\n    'id': 'route',\r\n    'source': 'route',\r\n    'type': 'line',\r\n    'paint': {\r\n    'line-width': 2,\r\n    'line-color': '#007cbf'\r\n    }\r\n    });\r\n\r\n    map.addLayer({\r\n      'id': 'points',\r\n      'type': 'symbol',\r\n      'source': 'points',\r\n      'layout': {\r\n        'icon-image': 'custom-marker',\r\n        // get the title name from the source's \"title\" property\r\n        'text-field': ['get', 'title'],\r\n        'text-font': [\r\n          'Open Sans Semibold',\r\n          'Arial Unicode MS Bold'\r\n        ],\r\n        'text-offset': [0, 1.25],\r\n        'text-anchor': 'top'\r\n      },\r\n      paint: {\r\n        \"text-color\": \"white\"\r\n      }\r\n    });\r\n    \r\n    map.addLayer({\r\n    'id': 'point',\r\n    'source': 'point',\r\n    'type': 'symbol',\r\n    'layout': {\r\n    'icon-image': 'ferry-15',\r\n    'icon-rotate': ['get', 'bearing'],\r\n    'icon-rotation-alignment': 'map',\r\n    'icon-allow-overlap': true,\r\n    'icon-ignore-placement': true\r\n    }\r\n    });\r\n\r\n    let point_a;\r\n    let point_b;\r\n\r\n\r\n    //Prøve å få denne til å kjøre for hver strekning\r\n    /*for (let i = 0; i < totalroute.length - 1; i++ ) {\r\n      console.log(\"DUM FOR-LOOP\");\r\n      //console.log(\"RUTE\", i)\r\n      let arc = [];\r\n      point_a = totalroute[i];\r\n      point_b = totalroute[i+1];\r\n      let route = {\r\n        'type': 'FeatureCollection',\r\n        'features': [\r\n          {\r\n            'type': 'Feature',\r\n            'geometry': {\r\n              'type': 'LineString',\r\n              'coordinates': [point_a, point_b]\r\n            }\r\n          }\r\n          ]\r\n        };\r\n      let lineDistance = turf.length(route.features[0]);\r\n      //console.log(\"lineDistance\", lineDistance)\r\n      counter = 0;\r\n      // Number of steps to use in the arc and animation, more steps means\r\n      // a smoother arc and animation, but too many steps will result in a\r\n      // low frame rate\r\n      // Draw an arc between the `origin` & `destination` of the two points\r\n      for (let i = 0; i < lineDistance; i += lineDistance / steps) {\r\n        let segment = turf.along(route.features[0], i);\r\n        arc.push(segment.geometry.coordinates);\r\n      }\r\n      // Update the route with calculated arc coordinates\r\n      route.features[0].geometry.coordinates = arc;\r\n      animate(counter, point_a);\r\n\r\n    }*/\r\n    let route_animate;\r\n    //animere en del per klikk\r\n    let route_counter = 0;\r\n    map.flyTo({\r\n      center: halifax,\r\n      zoom: 5.8,\r\n    })\r\n    document.getElementById('replay')\r\n    document.addEventListener('click', function () {\r\n      console.log(\"KUL KLIKK-RUTE\", route_counter);\r\n      console.log(\"RUTE\", route_counter)\r\n      let arc = [];\r\n      point_a = totalroute[route_counter];\r\n      point_b = totalroute[route_counter+1];\r\n      route_animate = {\r\n        'type': 'FeatureCollection',\r\n        'features': [\r\n          {\r\n            'type': 'Feature',\r\n            'geometry': {\r\n              'type': 'LineString',\r\n              'coordinates': [point_a, point_b]\r\n            }\r\n          }\r\n          ]\r\n        };\r\n      let lineDistance = turf.length(route_animate.features[0]);\r\n      //console.log(\"lineDistance\", lineDistance)\r\n      counter = 0;\r\n      // Number of steps to use in the arc and animation, more steps means\r\n      // a smoother arc and animation, but too many steps will result in a\r\n      // low frame rate\r\n      let steps = 150;      \r\n      // Draw an arc between the `origin` & `destination` of the two points\r\n      for (let i = 0; i < lineDistance * 1.10; i += (lineDistance) / (steps) ) {\r\n        let segment = turf.along(route_animate.features[0], i);\r\n        arc.push(segment.geometry.coordinates);\r\n      }\r\n      // Update the route with calculated arc coordinates\r\n      route_animate.features[0].geometry.coordinates = arc;\r\n      animate(counter, point_a, point_b);\r\n      map.flyTo({\r\n        center: point_b,\r\n        zoom: 5.95,\r\n        speed: 0.8,\r\n        essential: true // this animation is considered essential with respect to prefers-reduced-motion\r\n      });\r\n      console.log(\"currentDate: \", currentDate)\r\n      /*if (route_counter >= totalroute.length) {\r\n        route_counter = 0;\r\n      }\r\n      // Set the coordinates of the original point back to origin\r\n      //point.features[0].geometry.coordinates = origin;\r\n      \r\n      point.features[0].geometry.coordinates = totalroute[route_counter]\r\n\r\n      // Update the source layer\r\n      map.getSource('point').setData(point);\r\n      \r\n      // Reset the counter\r\n      counter = 0;\r\n      \r\n      //  Restart the animation\r\n      animate(counter);*/\r\n      route_counter += 1;\r\n      changeDate(route_counter)\r\n    });\r\n\r\n    function changeDate(route_counter) {\r\n      console.log(currentDate)\r\n      console.log(\"trying to set current date\");\r\n      setCurrentDate(dates[route_counter]);\r\n      console.log(currentDate)\r\n      console.log(\"current date hopefully set\")\r\n    }\r\n    \r\n    //faktiske animasjonsfunksjonen\r\n    function animate() {\r\n      //console.log(route_counter)\r\n      //console.log(\"a\", point_a, \"b\", point_b);\r\n      //console.log(\"POINT\", point_a)\r\n      //console.log(\"animate @201\")\r\n      let start =\r\n      route_animate.features[0].geometry.coordinates[\r\n      counter >= steps ? counter - 1 : counter\r\n      ];\r\n      let end =\r\n      route_animate.features[0].geometry.coordinates[\r\n      counter >= steps ? counter : counter + 1\r\n      ];\r\n      if (!start || !end) return;\r\n      \r\n      // Update point geometry to a new position based on counter denoting\r\n      // the index to access the arc\r\n      point.features[0].geometry.coordinates = route_animate.features[0].geometry.coordinates[counter];\r\n      \r\n      // Calculate the bearing to ensure the icon is rotated to match the route arc\r\n      // The bearing is calculated between the current point and the next point, except\r\n      // at the end of the arc, which uses the previous point and the current point\r\n      point.features[0].properties.bearing = turf.bearing(\r\n      turf.point(start),\r\n      turf.point(end)\r\n      );\r\n      \r\n      // Update the source with this new data\r\n      map.getSource('point').setData(point);\r\n      \r\n      // Request the next frame of animation as long as the end has not been reached\r\n      if (counter < steps) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n      \r\n      counter = counter + 1;\r\n    }\r\n    \r\n\r\n    \r\n    \r\n      // Start the animation\r\n      //animate(counter);\r\n    });\r\n\r\n      //add base layers to the map and sets mapLayers\r\n      function addLayers() {\r\n        let mapLayers = map.getStyle().sources;\r\n        if(!(\"gloshaugen\" in mapLayers)) {\r\n          addNewLayer(\"gloshaugen\", gloshaugen);\r\n        }\r\n        if(!(\"trondheim_vann\" in mapLayers)) {\r\n          addNewLayer(\"trondheim_vann\", trondheim_vann);\r\n        }\r\n        if(!(\"trondheim_veg\" in mapLayers)) {\r\n          addNewLayer(\"trondheim_veg\", trondheim_veg);\r\n        }\r\n        if(!(\"trondheim_bygg\" in mapLayers)) {\r\n          addNewLayer(\"trondheim_bygg\", trondheim_bygg);\r\n        }\r\n        let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n        if(mapSourceLength === 0) {\r\n          //in case the last layer was removed from the map, mapLayers is set to an empty array\r\n          setMapLayers([]);\r\n        } else {\r\n          //updates mapLayers if there are still layers left\r\n          let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n          setMapLayers(mapLayersInOrder);\r\n        }\r\n        updateButtons();\r\n      }\r\n\r\n      //pops a prompt for the user to pick a name for the new layer, if no name is chosen, no layer is added\r\n      function addNewLayer(layerName, data) {\r\n        try{\r\n          setTimeout(() => {\r\n            let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n            if(mapSourceLength === 0) {\r\n              //in case the last layer was removed from the map, mapLayers is set to an empty array\r\n              setMapLayers([]);\r\n            } else {\r\n              //updates mapLayers if there are still layers left\r\n              let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n              setMapLayers(mapLayersInOrder);\r\n            }\r\n            updateButtons();\r\n          }, 350);\r\n          let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n          if(mapSourceLength > 0) {\r\n            let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n            setMapLayers(mapLayersInOrder);\r\n          }\r\n          if(layerName === null) {\r\n            layerName = prompt(\"Enter a name for your layer\");\r\n          }\r\n          if (layerName === null || layerName === \"\") {\r\n            //nothing happens if the prompt is cancelled or if no name is typed into the prompt\r\n          } else {\r\n            let layerType;\r\n            if(data.type === \"Feature\") {\r\n              layerType = data.geometry.type;\r\n              \r\n            } else if(data.type === \"FeatureCollection\") {\r\n              layerType = data.features[0].geometry.type;\r\n            } else {\r\n              console.log(\"we have something else\");\r\n            }\r\n            //checks what kind of layer the data is referring to and adds the corresponding type of layer\r\n            if(layerType === \"Polygon\" || layerType === \"MultiPolygon\") {\r\n              //checks if layerType is polygon or multipolygon and adds the data as a polygon layer\r\n              map.addSource(layerName, {\r\n                type: \"geojson\",\r\n                data: data,\r\n              })\r\n              map.addLayer({\r\n                \"id\": layerName,\r\n                \"type\": \"fill\",\r\n                \"source\": layerName,\r\n                \"paint\": {\r\n                  \"fill-color\": randomizeColor(),\r\n                  \"fill-opacity\": 1,\r\n                }\r\n              })\r\n            } else if (layerType === \"Line\" || layerType === \"MultiLineString\") {\r\n              //checks if layerType is line or multilinestring and adds the data as a line layer\r\n              map.addSource(layerName, {\r\n                type: \"geojson\",\r\n                data: data,\r\n              })\r\n              map.addLayer({\r\n                \"id\": layerName,\r\n                \"type\": \"line\",\r\n                \"source\": layerName,\r\n                \"layout\": {\r\n                  \"line-join\": \"round\",\r\n                  \"line-cap\": \"round\"\r\n                },\r\n                \"paint\": {\r\n                  \"line-color\": randomizeColor(),\r\n                  \"fill-opacity\": 1,\r\n                  \"line-width\": 4,\r\n                }\r\n              })\r\n            } else if(layerType === \"Point\" || layerType === \"MultiPoint\") {\r\n              //checks if layerType a point or multipoint and adds the data as a point layer\r\n              map.addSource(layerName, {\r\n                type: \"geojson\",\r\n                data: data,\r\n              })\r\n              map.addLayer({\r\n                \"id\": layerName,\r\n                \"type\": \"circle\",\r\n                \"source\": layerName,\r\n                \"paint\": {\r\n                  \"circle-radius\": {\r\n                    'base': 2,\r\n                    'stops': [[12, 2], [16, 5]]\r\n                  },\r\n                  \"circle-color\": randomizeColor(),\r\n                }\r\n              })\r\n            }\r\n          }\r\n        }\r\n        catch(err) {\r\n          alert(\"Could not add layer\");\r\n        }\r\n      }\r\n\r\n      //removes all layers added to the map\r\n      function removeAllLayers() {\r\n        try{\r\n          let layerSources = map.getStyle().sources;\r\n          setTimeout(() => {\r\n            for (let layerSource in layerSources) {\r\n              if(layerSource !== \"composite\") {\r\n                try{\r\n                  map.removeLayer(layerSource);\r\n                  map.removeSource(layerSource);\r\n                }\r\n                catch(err) {\r\n                  alert(err);\r\n                }\r\n              }\r\n            }}, 350);\r\n        }\r\n        catch(err) {\r\n          alert(err);\r\n        }\r\n        setTimeout(() => {\r\n          setMapLayers([]);\r\n          updateButtons();\r\n        }, 350);\r\n      }\r\n\r\n      //removes a single layer from the map\r\n      function removeSingleLayer() {\r\n        try{\r\n          let selectedLayer = this.id;\r\n          try {\r\n            map.removeLayer(selectedLayer);\r\n            map.removeSource(selectedLayer);\r\n          }\r\n          catch(err) {\r\n            alert(err);\r\n          }\r\n          //updates mapLayers\r\n          setTimeout(() => {\r\n            let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n            if(mapSourceLength === 0) {\r\n              //in case the last layer was removed from the map, mapLayers is set to an empty array\r\n              setMapLayers([]);\r\n            } else {\r\n              //updates mapLayers if there are still layers left\r\n              let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n              setMapLayers(mapLayersInOrder);\r\n            }\r\n            updateButtons();\r\n          }, 350);\r\n        }\r\n        catch(err) {\r\n          alert(err);\r\n        }\r\n      }\r\n\r\n      //creates a buffer around the selected layer\r\n      function createBuffer() {\r\n        toggleSpinner();\r\n        setTimeout(() => {\r\n          try{\r\n            let selectedLayer = document.getElementById(\"bufferSelectLayer\").value;\r\n            let bufferSize = document.getElementById(\"bufferInputField\").value/1000;\r\n            if(bufferSize > 0) {\r\n              let turfed;\r\n              if (map.getSource(selectedLayer)._data.type === \"FeatureCollection\") {\r\n                turfed = map.getSource(selectedLayer)._data;\r\n              } else {\r\n                let features = map.getSource(selectedLayer)._data.features;\r\n                turfed = turf.featureCollection(features);\r\n              }\r\n              \r\n              let bufferData = buffer(turfed, bufferSize);\r\n              addNewLayer(null, bufferData);\r\n              setTimeout(() => {\r\n                let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n                if(mapSourceLength === 0) {\r\n                  setMapLayers([]);\r\n                } else {\r\n                  let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                  setMapLayers(mapLayersInOrder);\r\n                }\r\n                updateButtons();\r\n                toggleSpinner();\r\n              }, 350);\r\n            } else {\r\n              toggleSpinner();\r\n              alert(\"Please choose a buffer size greater than 0\");\r\n            }\r\n          }\r\n          catch(err) {\r\n            toggleSpinner();\r\n            alert(\"Please pick a layer and a buffer size\");\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      //creates a union between two layers of the same type\r\n      function createUnion() {\r\n        toggleSpinner();\r\n        setTimeout(() => {\r\n          try{\r\n            //finds which layers the user wants to create a union from\r\n            let selectedLayer1 = document.getElementById(\"unionSelectLayer1\").value;\r\n            let selectedLayer2 = document.getElementById(\"unionSelectLayer2\").value;\r\n            //finds the types of the layers to check that they are of the same type\r\n            let layerType1 = map.getSource(selectedLayer1)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            let layerType2 = map.getSource(selectedLayer2)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            if(layerType1 === layerType2) {\r\n              //union does not support multifeatures, so each feature must be individually added to the union \r\n              let currUnion = turf.union(map.getSource(selectedLayer1)._data.features[0], map.getSource(selectedLayer2)._data.features[0]);\r\n              for(let i = 1; i < map.getSource(selectedLayer1)._data.features.length; i++) {\r\n                currUnion = turf.union(currUnion, map.getSource(selectedLayer1)._data.features[i]);\r\n              }\r\n              for(let i = 1; i < map.getSource(selectedLayer2)._data.features.length; i++) {\r\n                currUnion = turf.union(currUnion, map.getSource(selectedLayer2)._data.features[i]);\r\n              }\r\n              //changes the type of the union result to feature collection if needed\r\n              if(currUnion.type === \"Feature\") {\r\n                currUnion = turf.featureCollection([currUnion]);\r\n              }\r\n              //adds the new layer to the map and updates mapLayers and buttons\r\n              addNewLayer(null, currUnion);\r\n              setTimeout(() => {\r\n                let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n                if(mapSourceLength === 0) {\r\n                  setMapLayers([]);\r\n                } else {\r\n                  let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                  setMapLayers(mapLayersInOrder);\r\n                }\r\n                updateButtons();\r\n                toggleSpinner();\r\n              }, 350);\r\n            } else {\r\n              toggleSpinner();\r\n              alert(\"Choose two layers of the same type\");\r\n            }\r\n          }\r\n          catch(err) {\r\n            toggleSpinner();\r\n            alert(\"Pick two layers that are of the same type\");\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      //creates intersection between two layers\r\n      function createIntersect() {\r\n        toggleSpinner();\r\n        setTimeout(() => {\r\n          try {\r\n            let selectedLayer1 = document.getElementById(\"intersectSelectLayer1\").value;\r\n            let selectedLayer2 = document.getElementById(\"intersectSelectLayer2\").value;\r\n            let layerType1 = map.getSource(selectedLayer1)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            let layerType2 = map.getSource(selectedLayer2)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            if(layerType1 === \"Polygon\" && layerType2 === \"Polygon\") {\r\n              //turf.intersect accepts single features, so it is needed to iterate through the features and combining them into a single feature\r\n              let unioned =  map.getSource(selectedLayer1)._data.features[0];\r\n              if(map.getSource(selectedLayer1)._data.features.length > 1) {\r\n                for(let i = 1; i < map.getSource(selectedLayer1)._data.features.length; i++) {\r\n                  unioned = turf.union(unioned, map.getSource(selectedLayer1)._data.features[i]);\r\n                }\r\n              }\r\n              //instead of finding the intersection, we find first find the difference between the two layers\r\n              let currDiff = turf.difference(unioned, map.getSource(selectedLayer2)._data.features[0]);\r\n              for(let i = 1; i < map.getSource(selectedLayer2)._data.features.length; i++) {\r\n                currDiff = turf.difference(currDiff, map.getSource(selectedLayer2)._data.features[i]);\r\n              }\r\n              //then we find the difference between the first layer and the difference from earlier to get the intersection\r\n              let intersected = turf.difference(unioned, currDiff);\r\n              for(let i = 1; i < map.getSource(selectedLayer2)._data.features.length; i++) {\r\n                intersected = turf.difference(intersected, map.getSource(selectedLayer2)._data.features[i]);\r\n              }\r\n              if(intersected.type === \"Feature\") {\r\n                intersected = turf.featureCollection([intersected]);\r\n              }\r\n              //doing difference twice instead of doing intersection once will probably affect run time, but it was easier working with difference as it accepts multipolygons\r\n              addNewLayer(null, intersected)\r\n              setTimeout(() => {\r\n                let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n                if(mapSourceLength === 0) {\r\n                  setMapLayers([]);\r\n                } else {\r\n                  let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                  setMapLayers(mapLayersInOrder);\r\n                }\r\n                updateButtons();\r\n                toggleSpinner();\r\n              }, 350);\r\n            } else {\r\n              toggleSpinner();\r\n              alert(\"Pick two polygon layers\");\r\n            }\r\n          }\r\n          catch(err) {\r\n            toggleSpinner();\r\n            alert(\"Please pick two polygon layers\");\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      //finds the difference between two layers, with focus being on the first layer\r\n      function createDifference() {\r\n        toggleSpinner();\r\n        setTimeout(() => {\r\n          try {\r\n            //does the same as intersect except for the second difference operation\r\n            let selectedLayer1 = document.getElementById(\"differenceSelectLayer1\").value;\r\n            let selectedLayer2 = document.getElementById(\"differenceSelectLayer2\").value;\r\n            let layerType1 = map.getSource(selectedLayer1)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            let layerType2 = map.getSource(selectedLayer2)._data.features[0].geometry.type.replace(\"Multi\", \"\");\r\n            if(layerType1 === \"Polygon\" && layerType2 === \"Polygon\") {\r\n              let unioned =  map.getSource(selectedLayer1)._data.features[0];\r\n              if(map.getSource(selectedLayer1)._data.features.length > 1) {\r\n                for(let i = 1; i < map.getSource(selectedLayer1)._data.features.length; i++) {\r\n                  unioned = turf.union(unioned, map.getSource(selectedLayer1)._data.features[i]);\r\n                }\r\n              } else {\r\n                unioned = map.getSource(selectedLayer1)._data.features[0];\r\n              }\r\n              let currDiff = turf.difference(unioned, map.getSource(selectedLayer2)._data.features[0]);\r\n              for(let i = 1; i < map.getSource(selectedLayer2)._data.features.length; i++) {\r\n                currDiff = turf.difference(currDiff, map.getSource(selectedLayer2)._data.features[i]);\r\n              }\r\n              if(currDiff === null) {\r\n                //as order matters when doing difference, it is possible for the user to use the wrong order and get no result\r\n                //this happens if the entirity of layer 1 is covered by layer 2\r\n                alert(\"Make sure you have selected two different layers and in the correct order\");\r\n              } else {\r\n                if(currDiff.type === \"Feature\") {\r\n                  currDiff = turf.featureCollection([currDiff]);\r\n                }\r\n                addNewLayer(null, currDiff)\r\n                setTimeout(() => {\r\n                  let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n                  if(mapSourceLength === 0) {\r\n                    setMapLayers([]);\r\n                  } else {\r\n                    let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                    setMapLayers(mapLayersInOrder);\r\n                  }\r\n                  updateButtons();\r\n                  toggleSpinner();\r\n                }, 350);\r\n              }\r\n            } else {\r\n              toggleSpinner();\r\n              alert(\"Pick two polygon layers\");\r\n            }\r\n          }\r\n          catch(err) {\r\n            toggleSpinner();\r\n            alert(\"Please pick two polygon layers\");\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      //creates a single point from given coordinates\r\n      function createPoint() {\r\n        //changes the coordinate values from strings to floats\r\n        let longCoord = parseFloat(document.getElementById(\"createPointLong\").value);\r\n        let latCoord = parseFloat(document.getElementById(\"createPointLat\").value);\r\n        //creates a feature collection from the point\r\n        if((!isNaN(longCoord) && !isNaN(latCoord)) && (longCoord <= 180 && longCoord >= -180) && (latCoord <= 85 && latCoord >= -85) ) {\r\n          let data = {\"type\": \"FeatureCollection\", \r\n            \"features\": [\r\n              {\r\n                \"type\": \"Feature\",\r\n                \"geometry\": {\r\n                \"type\": \"Point\",\r\n                \"coordinates\": [\r\n                  longCoord,\r\n                  latCoord\r\n                ]\r\n              }\r\n            }]\r\n          }\r\n          addNewLayer(null, data);\r\n          setTimeout(() => {\r\n            let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n              if(mapSourceLength === 0) {\r\n                setMapLayers([]);\r\n              } else {\r\n                let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                setMapLayers(mapLayersInOrder);\r\n              }\r\n            updateButtons();\r\n          }, 350);\r\n        } else {\r\n          alert(\"Please provide coordinates for the point you want to make\")\r\n        }\r\n      }\r\n\r\n      //changes the visibility of a single layer depends on if it is visible or not\r\n      function showOrHide() {\r\n        let selectedLayer = this.id;\r\n        let visibility = map.getLayoutProperty(selectedLayer, \"visibility\");\r\n        if(visibility === \"visible\" || visibility === undefined) {\r\n          map.setLayoutProperty(selectedLayer, \"visibility\", \"none\");\r\n          this.textContent = \"Show\";\r\n        } else {\r\n          map.setLayoutProperty(selectedLayer, \"visibility\", \"visible\");\r\n          this.textContent = \"Hide\";\r\n        }\r\n      }\r\n\r\n      //creates a random color to be used for new layers\r\n      function randomizeColor() {\r\n        let colorLetters = \"0123456789ABCDEF\";\r\n        let randomColor = \"#\";\r\n        for (let i = 0; i < 6; i++) {\r\n          randomColor += colorLetters[Math.floor(Math.random() * colorLetters.length)];\r\n        }\r\n        return randomColor;\r\n      }\r\n\r\n      //listener that listens to input and if the input type is color changes the color of a layer\r\n      document.addEventListener(\"input\", function(event) {\r\n        if(event.target.type === \"color\") {\r\n          map.setPaintProperty(event.target.id, \"fill-color\", event.target.value);\r\n        }\r\n      })\r\n\r\n\r\n\r\n      let dragging = null;\r\n      //listener that detects if an object gets dragged\r\n      document.addEventListener('dragstart', function(event) {\r\n        let target = getLI( event.target );\r\n        dragging = target;\r\n        event.dataTransfer.setData('text/plain', null);\r\n      });\r\n\r\n      //listener that detects if a draggable object is dragged over another draggable object and then shows where the dragged object will be dropped when dropped\r\n      document.addEventListener('dragover', function(event) {\r\n        try {\r\n          event.preventDefault();\r\n          let target = getLI( event.target );\r\n          let bounding = target.getBoundingClientRect()\r\n          let offset = bounding.y + (bounding.height/2);\r\n          if ( event.clientY - offset > 0 ) {\r\n            target.style['border-bottom'] = 'solid 75px white';\r\n            target.style['border-top'] = '';\r\n          } else {\r\n            target.style['border-top'] = 'solid 75px white';\r\n            target.style['border-bottom'] = '';\r\n          }\r\n        }\r\n        catch(err) {\r\n        }\r\n      });\r\n\r\n      //listener that detects if a draggable object is dragged out of a element\r\n      document.addEventListener('dragleave', function(event) {\r\n        try {\r\n          let target = getLI( event.target );\r\n          target.style['border-bottom'] = '';\r\n          target.style['border-top'] = '';\r\n        }\r\n        catch(err) {\r\n        }\r\n      });\r\n\r\n      //listener that detects if a draggable object is dropped and moves the corresponding layer to the wanted position with regards to the z-axis\r\n      document.addEventListener('drop', function(event) {\r\n        try {\r\n          event.preventDefault();\r\n          let target = getLI( event.target );\r\n          if ( target.style['border-bottom'] !== '' ) {\r\n            target.style['border-bottom'] = '';\r\n            target.parentNode.insertBefore(dragging, event.target.nextSibling);\r\n          } else {\r\n            target.style['border-top'] = '';\r\n            target.parentNode.insertBefore(dragging, event.target);\r\n          }\r\n          if(dragging.previousSibling) {\r\n            map.moveLayer(dragging.id, dragging.previousSibling.id);\r\n          } else {\r\n            map.moveLayer(dragging.id);\r\n          }\r\n          setMapLayers([]);\r\n          setTimeout(() => {\r\n            let mapSourceLength = Object.keys(map.getStyle().sources).length - 1;\r\n              if(mapSourceLength === 0) {\r\n                setMapLayers([]);\r\n              } else {\r\n                let mapLayersInOrder = map.getStyle().layers.slice(-1 * mapSourceLength).map(function (obj) { return obj.id; });\r\n                setMapLayers(mapLayersInOrder);\r\n              }\r\n            updateButtons();\r\n          }, 25);\r\n        }\r\n        catch(err) {\r\n        }\r\n      });\r\n\r\n      function getLI( target ) {\r\n          while ( target.nodeName.toLowerCase() !== 'li' && target.nodeName.toLowerCase() !== 'body' ) {\r\n              target = target.parentNode;\r\n          }\r\n          if ( target.nodeName.toLowerCase() === 'body' ) {\r\n              return false;\r\n          } else {\r\n              return target;\r\n          }\r\n      }\r\n\r\n      //switches between showing and hiding the spinner indicating that the application is working\r\n      function toggleSpinner() {\r\n        let spinner = document.getElementById(\"loadingspinner\");\r\n        if(spinner.style.display === \"block\") {\r\n          spinner.style.display = \"none\";\r\n        } else if(spinner.style.display === \"none\") {\r\n          spinner.style.display = \"block\"\r\n        }\r\n      }\r\n\r\n      //updates the buttons to ensure that the buttons to new layers works\r\n      function updateButtons() {\r\n        let functionality = document.getElementById('functionality');\r\n        let buttons = functionality.getElementsByTagName('button');\r\n        for(let i = 0; i < buttons.length; i++) {\r\n          if(buttons[i].id === \"addBaseLayersButton\") {\r\n            buttons[i].onclick = addLayers;\r\n          }\r\n          else if(buttons[i].id === \"removeAllLayersButton\") {\r\n            buttons[i].onclick = removeAllLayers;\r\n          }\r\n          else if(buttons[i].id === \"bufferButton\") {\r\n            buttons[i].onclick = createBuffer;\r\n          }\r\n          else if(buttons[i].id === \"unionButton\") {\r\n            buttons[i].onclick = createUnion;\r\n          }\r\n          else if(buttons[i].id === \"intersectButton\") {\r\n            buttons[i].onclick = createIntersect;\r\n          }\r\n          else if(buttons[i].id === \"differenceButton\") {\r\n            buttons[i].onclick = createDifference;\r\n          }\r\n          else if(buttons[i].textContent === \"Hide\" || buttons[i].textContent === \"Show\") {\r\n            buttons[i].onclick = showOrHide;\r\n          }\r\n          else if(buttons[i].textContent === \"Delete\") {\r\n            buttons[i].onclick = removeSingleLayer;\r\n          }\r\n          else if(buttons[i].id === \"createPointButton\") {\r\n            buttons[i].onclick = createPoint;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    if (!map) initializeMap({ setMap, mapContainer });\r\n  }, [map, mapLayers]);\r\n\r\n  return (\r\n    <div>\r\n      <div className=\"container\">\r\n        \r\n        <div className=\"mapcontainer\">\r\n          <div ref={el => (mapContainer.current = el)} className=\"map\" />\r\n          <div class=\"map-overlay top\">\r\n            <div class=\"map-overlay-inner\">\r\n              <fieldset>\r\n                <label>Avreise - Ankomst:</label>\r\n                <label>{currentDate}</label>\r\n                <div id=\"swatches\"></div>\r\n              </fieldset>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n\r\nexport default Map;","import React from \"react\";\r\nimport Map from \"./components/Map/Map\";\r\nimport \"./App.css\";\r\n//import Map2 from \"./components/Map2/Map2\";\r\n\r\nconst styles = {\r\n  overflow:'hidden',\r\n}\r\n\r\nfunction App() {\r\n\r\n\r\n  return (\r\n    <div style={styles}>\r\n      <div id=\"map\"></div>\r\n      <Map />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}